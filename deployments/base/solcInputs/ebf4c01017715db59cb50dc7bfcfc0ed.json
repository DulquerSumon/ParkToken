{
  "language": "Solidity",
  "sources": {
    "contracts/LilRollsICO.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _contextSuffixLength() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    error OwnableUnauthorizedAccount(address account);\r\n    error OwnableInvalidOwner(address owner);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    constructor(address initialOwner) {\r\n        if (initialOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != _msgSender()) {\r\n            revert OwnableUnauthorizedAccount(_msgSender());\r\n        }\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n}\r\ninterface AggregatorV3Interface {\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n}\r\ncontract LilRollsICO is Ownable {\r\n    error NotStarted();\r\n    error AmountNotAvailableForSale();\r\n    error RoundNotMatch();\r\n    error TransferFailed();\r\n    error SCNotAllowed();\r\n    error AlreadyEnabled();\r\n    error Invalid();\r\n    error LengthError();\r\n    error AmountZero();\r\n    error VestingNotEnabled();\r\n    IERC20 private token;\r\n    TokenPriceInUSD private tokenPriceInUSD;\r\n    uint256 private precision = 10000;\r\n    address payable projectWallet;\r\n    uint256 private roundPeriod;\r\n    mapping(address => bool) private isAllowedStableCoin;\r\n    mapping(address => UserInfo) private userInfo;\r\n    RoundTimeInfo private roundTimeInfo;\r\n    RoundHardCapInfo private roundHardCapInfo;\r\n    RoundTokenSaleInfo private roundTokenSaleInfo;\r\n    ICOInfo private icoInfo;\r\n    bool private isICOEnabled;\r\n    bool private isVestingEnabled;\r\n    address[] private teamAndDevMembers;\r\n    uint256 private claimStartedAt;\r\n    uint256 private minimumDelayBetweenClaim;\r\n    mapping(address => uint256) private memberToTotalAmount;\r\n    mapping(address => uint256) private memberToTotalAmountClaimed;\r\n    mapping(address => uint256) private memberLastClaimedAT;\r\n    AggregatorV3Interface priceFeed;\r\n\r\n    struct RoundTimeInfo {\r\n        uint256 r1StartTime;\r\n        uint256 r1EndTime;\r\n        uint256 r2StartTime;\r\n        uint256 r2EndTime;\r\n    }\r\n\r\n    struct RoundHardCapInfo {\r\n        uint256 r1HardCap;\r\n        uint256 r2HardCap;\r\n    }\r\n\r\n    struct RoundTokenSaleInfo {\r\n        uint256 r1SoldToken;\r\n        uint256 r1TokenForSale;\r\n        uint256 r2SoldToken;\r\n        uint256 r2TokenForSale;\r\n    }\r\n\r\n    struct UserInfo {\r\n        uint256 r1Purchased;\r\n        uint256 r2Purchased;\r\n        uint256 totalSCInvested;\r\n        uint256 totalBaseInvested;\r\n        uint256 totalPurchased;\r\n    }\r\n\r\n    struct ICOInfo {\r\n        uint256 raisedTotalBase;\r\n        uint256 raisedTotalSCToken;\r\n        uint256 soldToken;\r\n    }\r\n\r\n    struct TokenPriceInUSD {\r\n        uint256 round1;\r\n        uint256 round2;\r\n    }\r\n\r\n    enum PaymentType {\r\n        Base,\r\n        StableCoin\r\n    }\r\n\r\n    event TokenPurchased(\r\n        uint256 indexed tokenAmount,\r\n        uint256 indexed amountPaid,\r\n        address purchaser\r\n    );\r\n\r\n    constructor(\r\n        address _token,\r\n        address[] memory _allowedStableCoins,\r\n        uint256 _startingTime,\r\n        address payable _pWallet,\r\n        RoundHardCapInfo memory _capInfo,\r\n        TokenPriceInUSD memory _price,\r\n        address _oracle\r\n    ) Ownable(_pWallet) {\r\n        projectWallet = _pWallet;\r\n        roundHardCapInfo = _capInfo;\r\n        roundPeriod = 30 days;\r\n        priceFeed = AggregatorV3Interface(_oracle);\r\n        token = IERC20(_token);\r\n        for (uint256 i = 0; i < _allowedStableCoins.length; i++) {\r\n            isAllowedStableCoin[_allowedStableCoins[i]] = true;\r\n        }\r\n        roundTimeInfo.r1StartTime = _startingTime;\r\n        roundTimeInfo.r1EndTime = (roundTimeInfo.r1StartTime + roundPeriod) - 1;\r\n        roundTimeInfo.r2StartTime = roundTimeInfo.r1EndTime + 1;\r\n        roundTimeInfo.r2EndTime = (roundTimeInfo.r2StartTime + roundPeriod) - 1;\r\n\r\n        roundTokenSaleInfo.r1TokenForSale = roundHardCapInfo.r1HardCap;\r\n        roundTokenSaleInfo.r2TokenForSale = roundHardCapInfo.r2HardCap;\r\n        tokenPriceInUSD = _price;\r\n    }\r\n\r\n    function updateOracle(address _new) public onlyOwner {\r\n        priceFeed = AggregatorV3Interface(_new);\r\n    }\r\n\r\n    function updateToken(address _new) public onlyOwner {\r\n        if (isICOEnabled) {\r\n            revert AlreadyEnabled();\r\n        }\r\n        token = IERC20(_new);\r\n    }\r\n\r\n    function addAllowedStableCoin(\r\n        address[] memory _coins,\r\n        bool[] memory _status\r\n    ) public onlyOwner {\r\n        if (_coins.length != _status.length) {\r\n            revert LengthError();\r\n        }\r\n        for (uint256 i = 0; i < _coins.length; i++) {\r\n            isAllowedStableCoin[_coins[i]] = _status[i];\r\n        }\r\n    }\r\n\r\n    function enableICO() public onlyOwner {\r\n        if (isICOEnabled) {\r\n            revert AlreadyEnabled();\r\n        }\r\n        isICOEnabled = true;\r\n        uint256 amount = roundHardCapInfo.r1HardCap +\r\n            roundHardCapInfo.r2HardCap;\r\n        token.transferFrom(msg.sender, address(this), amount);\r\n    }\r\n\r\n    function updateVestingMode() public onlyOwner {\r\n        isVestingEnabled = !isVestingEnabled;\r\n    }\r\n\r\n    function enableVestingForTeamAndDev(\r\n        address[] memory _members,\r\n        uint256[] memory _amounts,\r\n        uint256 _claimStartAt\r\n    ) public onlyOwner {\r\n        if (_members.length != _amounts.length) {\r\n            revert LengthError();\r\n        }\r\n        claimStartedAt = _claimStartAt;\r\n        minimumDelayBetweenClaim = 30 days;\r\n        isVestingEnabled = true;\r\n        uint256 total;\r\n        for (uint256 i = 0; i < _members.length; i++) {\r\n            teamAndDevMembers.push(_members[i]);\r\n            memberToTotalAmount[_members[i]] += _amounts[i];\r\n            total += _amounts[i];\r\n        }\r\n        token.transferFrom(msg.sender, address(this), total);\r\n    }\r\n\r\n    function claimToken() public {\r\n        if (!isVestingEnabled) {\r\n            revert VestingNotEnabled();\r\n        }\r\n        if (memberToTotalAmount[msg.sender] <= 0) {\r\n            revert AmountZero();\r\n        }\r\n        uint256 timesCount;\r\n        if (memberLastClaimedAT[msg.sender] <= claimStartedAt) {\r\n            if (block.timestamp > claimStartedAt + minimumDelayBetweenClaim) {\r\n                timesCount =\r\n                    (block.timestamp - claimStartedAt) /\r\n                    minimumDelayBetweenClaim;\r\n            } else {\r\n                timesCount = 1;\r\n            }\r\n            memberLastClaimedAT[msg.sender] = block.timestamp;\r\n        } else if (memberLastClaimedAT[msg.sender] >= claimStartedAt) {\r\n            timesCount =\r\n                (block.timestamp - memberLastClaimedAT[msg.sender]) /\r\n                minimumDelayBetweenClaim;\r\n            memberLastClaimedAT[msg.sender] =\r\n                memberLastClaimedAT[msg.sender] +\r\n                (timesCount * minimumDelayBetweenClaim);\r\n        }\r\n        uint256 amount = memberToTotalAmount[msg.sender] / 24;\r\n        uint256 claimAmount = amount * timesCount;\r\n        if (\r\n            memberToTotalAmountClaimed[msg.sender] + claimAmount >\r\n            memberToTotalAmount[msg.sender]\r\n        ) {\r\n            claimAmount =\r\n                memberToTotalAmount[msg.sender] -\r\n                memberToTotalAmountClaimed[msg.sender];\r\n        }\r\n        if (claimAmount == 0) {\r\n            revert AmountZero();\r\n        }\r\n        memberToTotalAmountClaimed[msg.sender] += claimAmount;\r\n        token.transfer(msg.sender, claimAmount);\r\n    }\r\n\r\n    function updateRound1Time(\r\n        uint256 _startTime\r\n    ) public onlyOwner returns (bool) {\r\n        roundTimeInfo.r1StartTime = _startTime;\r\n        roundTimeInfo.r1EndTime = (roundTimeInfo.r1StartTime + roundPeriod) - 1;\r\n        roundTimeInfo.r2StartTime = roundTimeInfo.r1EndTime + 1;\r\n        roundTimeInfo.r2EndTime = (roundTimeInfo.r2StartTime + roundPeriod) - 1;\r\n        return true;\r\n    }\r\n\r\n    function updateRound2Time(\r\n        uint256 _startTime\r\n    ) public onlyOwner returns (bool) {\r\n        roundTimeInfo.r1EndTime = block.timestamp;\r\n        roundTimeInfo.r2StartTime = _startTime;\r\n        roundTimeInfo.r2EndTime = (roundTimeInfo.r2StartTime + roundPeriod) - 1;\r\n        return true;\r\n    }\r\n\r\n    function updateTokenPrice(\r\n        TokenPriceInUSD memory _price\r\n    ) public onlyOwner returns (bool) {\r\n        tokenPriceInUSD = _price;\r\n        return true;\r\n    }\r\n\r\n    function retrieveStuckedAsset(\r\n        address _tokenAddr,\r\n        uint256 _amount,\r\n        address _toWallet,\r\n        bool _base\r\n    ) public onlyOwner returns (bool) {\r\n        IERC20(_tokenAddr).transfer(_toWallet, _amount);\r\n        if (address(this).balance > 0 && _base) {\r\n            (bool success, ) = projectWallet.call{value: address(this).balance}(\r\n                \"\"\r\n            );\r\n            if (!success) revert TransferFailed();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    receive() external payable {\r\n        buy(PaymentType.Base, msg.value, address(0));\r\n    }\r\n\r\n    function buy(\r\n        PaymentType _type,\r\n        uint256 _amountToPay,\r\n        address _paymentToken\r\n    ) public payable returns (bool) {\r\n        if (tokenPriceInUSD.round1 == 0) {\r\n            revert NotStarted();\r\n        }\r\n        uint256 currentTime = block.timestamp;\r\n        address currentInvestor = msg.sender;\r\n        uint256 amountToPay;\r\n        UserInfo storage user = userInfo[currentInvestor];\r\n        if (_type == PaymentType.Base) {\r\n            amountToPay = getConversionRate(msg.value);\r\n            (bool success, ) = projectWallet.call{value: msg.value}(\"\");\r\n            if (!success) revert TransferFailed();\r\n            user.totalBaseInvested += msg.value;\r\n            icoInfo.raisedTotalBase += msg.value;\r\n        } else if (_type == PaymentType.StableCoin) {\r\n            amountToPay = _amountToPay;\r\n            if (!isAllowedStableCoin[_paymentToken]) {\r\n                revert SCNotAllowed();\r\n            }\r\n            IERC20(_paymentToken).transferFrom(\r\n                currentInvestor,\r\n                projectWallet,\r\n                amountToPay\r\n            );\r\n            user.totalSCInvested += amountToPay;\r\n            icoInfo.raisedTotalSCToken += amountToPay;\r\n        }\r\n\r\n        uint256 amount;\r\n\r\n        if (\r\n            currentTime >= roundTimeInfo.r1StartTime &&\r\n            currentTime <= roundTimeInfo.r1EndTime\r\n        ) {\r\n            amount = (amountToPay / tokenPriceInUSD.round1) * precision;\r\n            if (roundTokenSaleInfo.r1TokenForSale < amount) {\r\n                revert AmountNotAvailableForSale();\r\n            }\r\n            roundTokenSaleInfo.r1TokenForSale -= amount;\r\n            roundTokenSaleInfo.r1SoldToken += amount;\r\n            user.r1Purchased += amount;\r\n        } else if (\r\n            currentTime >= roundTimeInfo.r2StartTime &&\r\n            currentTime <= roundTimeInfo.r2EndTime\r\n        ) {\r\n            amount = (amountToPay / tokenPriceInUSD.round2) * precision;\r\n            if (roundTokenSaleInfo.r2TokenForSale < amount) {\r\n                revert AmountNotAvailableForSale();\r\n            }\r\n            roundTokenSaleInfo.r2TokenForSale -= amount;\r\n            roundTokenSaleInfo.r2SoldToken += amount;\r\n            user.r2Purchased += amount;\r\n        } else {\r\n            revert RoundNotMatch();\r\n        }\r\n        if (amount <= 0) {\r\n            revert AmountZero();\r\n        }\r\n        icoInfo.soldToken += amount;\r\n        user.totalPurchased += amount;\r\n        token.transfer(currentInvestor, amount);\r\n        emit TokenPurchased(amount, amountToPay, currentInvestor);\r\n        return true;\r\n    }\r\n\r\n    function getConversionRate(\r\n        uint256 bnbAmount\r\n    ) internal view returns (uint256) {\r\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\r\n        uint256 bnbPrice = uint256(answer) * 10000000000;\r\n        uint256 bnbAmountInUsd = (bnbPrice * bnbAmount) / 1000000000000000000;\r\n        return bnbAmountInUsd;\r\n    }\r\n\r\n    function round()\r\n        public\r\n        view\r\n        returns (\r\n            string memory _round,\r\n            uint256 endTime,\r\n            uint256 _hardcap,\r\n            uint256 _soldToken,\r\n            uint256 _price\r\n        )\r\n    {\r\n        uint256 currentTime = block.timestamp;\r\n        if (\r\n            currentTime >= roundTimeInfo.r1StartTime &&\r\n            currentTime <= roundTimeInfo.r1EndTime\r\n        ) {\r\n            string memory Round = \"PreSale 1\";\r\n            return (\r\n                Round,\r\n                roundTimeInfo.r1EndTime,\r\n                roundHardCapInfo.r1HardCap,\r\n                roundTokenSaleInfo.r1SoldToken,\r\n                tokenPriceInUSD.round1\r\n            );\r\n        } else if (\r\n            currentTime >= roundTimeInfo.r2StartTime &&\r\n            currentTime <= roundTimeInfo.r2EndTime\r\n        ) {\r\n            string memory Round = \"Public Sale 1\";\r\n            return (\r\n                Round,\r\n                roundTimeInfo.r2EndTime,\r\n                roundHardCapInfo.r2HardCap,\r\n                roundTokenSaleInfo.r2SoldToken,\r\n                tokenPriceInUSD.round2\r\n            );\r\n        } else {\r\n            require(false, \"Please check ICO time\");\r\n        }\r\n    }\r\n\r\n    function isRound1Completed() public view returns (bool) {\r\n        if (\r\n            block.timestamp > roundTimeInfo.r1EndTime ||\r\n            roundTokenSaleInfo.r1TokenForSale == 0\r\n        ) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function isRound2Completed() public view returns (bool) {\r\n        if (\r\n            block.timestamp > roundTimeInfo.r2EndTime ||\r\n            roundTokenSaleInfo.r2TokenForSale == 0\r\n        ) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function getICOInfo() public view returns (ICOInfo memory) {\r\n        return icoInfo;\r\n    }\r\n    function getRoundTimeInfo() public view returns (RoundTimeInfo memory) {\r\n        return roundTimeInfo;\r\n    }\r\n    function getRoundHardCapInfo()\r\n        public\r\n        view\r\n        returns (RoundHardCapInfo memory)\r\n    {\r\n        return roundHardCapInfo;\r\n    }\r\n    function getRoundTokenSaleInfo()\r\n        public\r\n        view\r\n        returns (RoundTokenSaleInfo memory)\r\n    {\r\n        return roundTokenSaleInfo;\r\n    }\r\n    function getUserInfo(address _user) public view returns (UserInfo memory) {\r\n        return userInfo[_user];\r\n    }\r\n    function getTokenPriceInUSD() public view returns (TokenPriceInUSD memory) {\r\n        return tokenPriceInUSD;\r\n    }\r\n\r\n    function getIsAllowedStableCoin(address _token) public view returns (bool) {\r\n        return isAllowedStableCoin[_token];\r\n    }\r\n\r\n    function getTeamAndDevMembers() public view returns (address[] memory) {\r\n        return teamAndDevMembers;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}